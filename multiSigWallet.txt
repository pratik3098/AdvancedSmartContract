pragma solidity ^0.6.2;

contract multiSigWallet{
 // Wallet supports maximum of three owners 
 // Types of consensus: 1. Majority 2. All 3. One of them
 // Type of contract operations: 4. sendEthers 5. addOwner 6. changeOwner
  uint consensusType =1;  // Defa
  uint walletBalance=0;
  address[] owners;
  mapping(address=>bytes32[6]) op_sings;
  event Receive(address src, uint value);
  
  constructor(uint _consensusType) public {
    require(1<= _consensusType && _consensusType <=3);
    owners.push(msg.sender);
    consensusType = _consensusType;
  }
  
 // Function to add new owner 
 // Requires consensus of all of current owners
 function addOwner(address _owner) public {
  require(owners.length < 3);
  bool approved= true;
  for(uint i=0; i< owners.length; i++){
  //  approved= recoverSigner(op_sings[owners[i]][4]) == owners[i];
    if(!approved)
    {
      break;
    }
     
  }
  require(approved, "Error: Invoke not valid");
  owners.push(_owner);
   for(uint i=0; i< owners.length; i++){
    op_sings[owners[i]][4]=0;
  }
 }
 
 function changeConsensusType(uint _type) public {
  require(1<= _type && _type <=3 );
  consensusType= _type;
 }
   
 function recoverSigner(bytes32 signMsg, bytes32 signature) internal pure returns (address)
  {
    bytes32 r;
    bytes32 s;
    uint8 v;
    require(signature.length == 65);
     assembly {
      r := mload(add(signature, 0x20))
      s := mload(add(signature, 0x40))
      v := byte(0, mload(add(signature, 0x60)))
    }  
    
    return ecrecover(signMsg, v, r, s);
  }
  
  function send(uint amount, address payable dst) public payable {
      dst.transfer(amount);
  }
  
  function recieve() external payable {
  emit Receive(msg.sender, msg.value);
    walletBalance+=msg.value;
  }
}