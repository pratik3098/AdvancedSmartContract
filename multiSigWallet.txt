pragma solidity ^0.6.2;

contract multiSigWallet{
 // Types of consensus: 1. Majority 2. All 3. One of them
 // Type of contract operations: 4. sendEthers 5. addOwner 6. changeConsensusType
 
  uint consensusType= 1;  
  uint walletBalance= 0;
  address[] owners;
  mapping(address=>bytes[3]) op_signs;
  event Receive(address src, uint value);
  
  constructor(uint _consensusType) public {
    require(1<= _consensusType && _consensusType <=3);
    owners.push(msg.sender);
    consensusType = _consensusType;
  }
  

 function addOwner(address _owner) public {
  require(owners.length < 3);
  require(consensus1(4), "Error: Invoke not valid");
  owners.push(_owner);
  clearSigns(5);
 }
 
 function changeConsensusType(uint _type) public {
  require(1<= _type && _type <=3 );
  consensusType= _type;
  clearSigns(6);
 }
 
 function signSendEthers(uint amt) public payable isOwner {
  op_signs[msg.sender][1]= abi.encodeWithSignature("\x19Ethereum Signed Message:\n",msg.sender,amt, block.timestamp);
 }
   
 function recoverSigner(bytes32 signMsg, bytes32  signature) internal pure returns (address)
  {
    bytes32 r;
    bytes32 s;
    uint8 v;
    require(signature.length == 65);
     assembly {
      r := mload(add(signature, 0x20))
      s := mload(add(signature, 0x40))
      v := byte(0, mload(add(signature, 0x60)))
    }  
    
    return ecrecover(signMsg, v, r, s);
  }
  
  function send(uint amount, address payable dst) public payable approved(4) {
      dst.transfer(amount);
      clearSigns(5);
  }
  
  function consensus1(uint op) internal view returns(bool){
  require(op>=4 && op<=6);
   bool approved= true;
    for(uint i=0; i< owners.length; i++){
   approved= recoverSigner(bytes32(""),bytes32(op_signs[owners[i]][op - 4])) == owners[i];
    if(!approved){
      break;
    }
  }
  return approved;
  }
  
  
  
 function consensus2(uint op) internal view returns(bool){
  uint counter = 0;
  uint midWay= (owners.length /2);
  bool approved= true;
  for(uint i=0; i< owners.length; i++){
  // approved= recoverSigner(op_sings[owners[i]][op - 4]) == owners[i];
    if(approved)
    {
      counter++;
    }
    if(counter >= midWay){
       return true;
    }
     
  }

  return false; 
  }
  
    
 function consensus3(uint op) internal view returns(bool){
  uint counter = 0;
  bool approved;
  for(uint i=0; i< owners.length; i++){
  // approved= recoverSigner(op_sings[owners[i]][op - 4]) == owners[i];
    if(approved){
    counter ++;
    }
    
    if(counter >=1)
    {
      return true;
    }
    
  }
 
  return false; 
  }
  
  
  function clearSigns(uint op) public {
    for(uint i=0; i< owners.length; i++){
    op_signs[owners[i]][op - 4]= "";
  }
  }
  

  modifier approved(uint op)  {
  bool appr;
  if (consensusType == 1)
    appr= consensus1(op);
  else if (consensusType == 2)
    appr = consensus2(op);
  else if (consensusType == 3)
    appr = consensus3(op);
    require(appr,"Error: Transcation not approved");
   _;
  }
  
  modifier isOwner{
  bool appr;
  for(uint i=0;i< owners.length;i++){
    appr = (owners[i] == msg.sender);
    if(appr)
    break;
  }
  require(appr,"Error: not owner");
   _;
  }
  
  function recieve() external payable {
  emit Receive(msg.sender, msg.value);
    walletBalance+=msg.value;
  }
}
