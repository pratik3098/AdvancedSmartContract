pragma solidity ^0.6.2;

contract multiSigWallet{
 // Wallet supports maximum of three owners 
 // Types of consensus: 1. Majority 2. All 3. One of them
 // Type of contract operations: 4. sendEthers 5. addOwner 6. changeOwner
  uint consensusType =1;  // Defa
  uint walletBalance=0;
  address[] owners;
  mapping(address=>bytes32[3]) op_sings;
  event Receive(address src, uint value);
  
  constructor(uint _consensusType) public {
    require(1<= _consensusType && _consensusType <=3);
    owners.push(msg.sender);
    consensusType = _consensusType;
  }
  
 // Function to add new owner 
 // Requires consensus of all of current owners
 function addOwner(address _owner) public {
  require(owners.length < 3);
  require(consensus1(4), "Error: Invoke not valid");
  owners.push(_owner);
  clearSigns(4);
 }
 
 function changeConsensusType(uint _type) public {
  require(1<= _type && _type <=3 );
  consensusType= _type;
 }
   
 function recoverSigner(bytes32 signMsg, bytes32 signature) internal pure returns (address)
  {
    bytes32 r;
    bytes32 s;
    uint8 v;
    require(signature.length == 65);
     assembly {
      r := mload(add(signature, 0x20))
      s := mload(add(signature, 0x40))
      v := byte(0, mload(add(signature, 0x60)))
    }  
    
    return ecrecover(signMsg, v, r, s);
  }
  
  function send(uint amount, address payable dst) public payable {
      dst.transfer(amount);
  }
  
  function consensus1(uint op) internal view returns(bool){
   bool approved= true;
    for(uint i=0; i< owners.length; i++){
  // approved= recoverSigner(op_sings[owners[i]][op - 3]) == owners[i];
    if(!approved){
      break;
    }
  }
  return approved;
  }
  
  
  
 function consensus2(uint op) internal view returns(bool){
  uint counter = 0;
  bool approved= true;
  for(uint i=0; i< owners.length; i++){
  // approved= recoverSigner(op_sings[owners[i]][op - 3]) == owners[i];
    if(!approved)
    {
      break;
    }
     counter++;
  }
 
  return (counter  >= (owners.length /2) ); 
  }
  
    
 function consensus3(uint op) internal view returns(bool){
  uint counter = 0;
  bool approved= true;
  for(uint i=0; i< owners.length; i++){
  // approved= recoverSigner(op_sings[owners[i]][op - 3]) == owners[i];
    if(!approved || counter >=1)
    {
      break;
    }
     counter++;
  }
 
  return (counter  >= 1 ); 
  }
  function clearSigns(uint op) public {
    for(uint i=0; i< owners.length; i++){
    op_sings[owners[i]][op - 3]=0;
  }
  }
  
  function recieve() external payable {
  emit Receive(msg.sender, msg.value);
    walletBalance+=msg.value;
  }
}
